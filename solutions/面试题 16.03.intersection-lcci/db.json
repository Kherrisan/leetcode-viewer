{"kotlin":"import kotlin.math.abs\nimport kotlin.math.min\nimport kotlin.math.max\n\nconst val E = 1e-6\n\nfun main() {\n    val a = Solution().intersection(intArrayOf(0, 3), intArrayOf(0, 6), intArrayOf(0, 1), intArrayOf(0, 5))\n    println(a.contentToString())\n}\n\nclass Solution {\n    fun inLine(x: Double, s: Double, e: Double): Boolean {   // 判断x是否在s->e或e->s之间\n        if (abs(x - s) < E || abs(x - e) < E) return true;\n        return (x - s > 0 && e - x > 0) || (x - e > 0 && s - x > 0);\n    }\n\n    fun intersection(start1: IntArray, end1: IntArray, start2: IntArray, end2: IntArray): DoubleArray {\n        //两条直线方程为 a1x+b1y+c1=0,a2x+b2y+c2=0\n        val x1 = start1[0];\n        val y1 = start1[1];\n        val x2 = end1[0];\n        val y2 = end1[1];\n        val x3 = start2[0];\n        val y3 = start2[1];\n        val x4 = end2[0];\n        val y4 = end2[1];\n        val a11 = y2 - y1;\n        val a12 = x1 - x2;\n        val b1 = x1 * y2 - x2 * y1;\n        val a21 = y4 - y3;\n        val a22 = x3 - x4;\n        val b2 = x3 * y4 - x4 * y3;\n        //两条直线的一般式方程\n        //a11x+a12y+b1=0\n        //a21x+a22y+b2=0\n        //联立，求方程组的解\n        val D = a11 * a22 - a12 * a21;  //系数矩阵的行列式\n        val D1 = b1 * a22 - a12 * b2;   //除掉第一列后的行列式\n        val D2 = a11 * b2 - b1 * a21;   //除掉第二列后的行列式\n        if (D == 0 && D1 == 0) {\n            //无穷多解——共线\n            if (min(x3, x4) > max(x1, x2) || min(x1, x2) > max(x3, x4))\n                return doubleArrayOf()\n            if (min(y3, y4) > max(y1, y2) || min(y1, y2) > max(y3, y4))\n                return doubleArrayOf()\n            //先按 x 排序，再按 y 排序，找到第二个点，就是交点\n            var v = listOf(listOf(x1, y1), listOf(x2, y2), listOf(x3, y3), listOf(x4, y4))\n            v = v.sortedBy { it[0] }\n            val res = mutableListOf<List<Int>>()\n            for(group in v.groupBy { it[0] }){\n                res.addAll(group.value.sortedBy { it[1] })\n            }\n            return doubleArrayOf(res[1][0].toDouble(), res[1][1].toDouble());\n        }\n        if (D != 0) {\n            //有解\n            val x0 = D1.toDouble() / D.toDouble();\n            val y0 = D2.toDouble() / D.toDouble()\n            if (inLine(x0, x1.toDouble(), x2.toDouble()) && inLine(x0, x3.toDouble(), x4.toDouble()) && inLine(\n                    y0,\n                    y1.toDouble(),\n                    y2.toDouble()\n                ) && inLine(y0, y3.toDouble(), y4.toDouble())\n            ) return doubleArrayOf(x0, y0);\n        }\n        //无解——平行\n        return doubleArrayOf()\n    }\n}"}