{"java":"class Solution {\n    private static final int INF = 1 << 20;\n    private Map<String, Integer> wordId; // 单词到id的映射\n    private ArrayList<String> idWord; // id到单词的映射\n    private ArrayList<Integer>[] edges; // 图的边\n\n    public Solution() {\n        wordId = new HashMap<>();\n        idWord = new ArrayList<>();\n    }\n\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        int id = 0;\n        // 将wordList所有单词加入wordId中 相同的只保留一个 // 并为每一个单词分配一个id\n        for (String word : wordList) {\n            if (!wordId.containsKey(word)) { \n                wordId.put(word, id++);\n                idWord.add(word);\n            }\n        }\n        // 若endWord不在wordList中 则无解\n        if (!wordId.containsKey(endWord)) {\n            return new ArrayList<>();\n        }\n        // 把beginWord也加入wordId中\n        if (!wordId.containsKey(beginWord)) {\n            wordId.put(beginWord, id++);\n            idWord.add(beginWord);\n        }\n\n        // 初始化存边用的数组\n        edges = new ArrayList[idWord.size()];\n        for (int i = 0; i < idWord.size(); i++) {\n            edges[i] = new ArrayList<>();\n        }\n        // 添加边\n        for (int i = 0; i < idWord.size(); i++) {\n            for (int j = i + 1; j < idWord.size(); j++) {\n                // 若两者可以通过转换得到 则在它们间建一条无向边\n                if (transformCheck(idWord.get(i), idWord.get(j))) {\n                    edges[i].add(j);\n                    edges[j].add(i);\n                }\n            }\n        }\n\n        int dest = wordId.get(endWord); // 目的ID\n        List<List<String>> res = new ArrayList<>(); // 存答案\n        int[] cost = new int[id]; // 到每个点的代价\n        for (int i = 0; i < id; i++) {\n            cost[i] = INF; // 每个点的代价初始化为无穷大\n        }\n\n        // 将起点加入队列 并将其cost设为0\n        Queue<ArrayList<Integer>> q = new LinkedList<>();\n        ArrayList<Integer> tmpBegin = new ArrayList<>();\n        tmpBegin.add(wordId.get(beginWord));\n        q.add(tmpBegin);\n        cost[wordId.get(beginWord)] = 0;\n\n        // 开始广度优先搜索\n        while (!q.isEmpty()) {\n            ArrayList<Integer> now = q.poll();\n            int last = now.get(now.size() - 1); // 最近访问的点\n            if (last == dest) { // 若该点为终点则将其存入答案res中\n                ArrayList<String> tmp = new ArrayList<>();\n                for (int index : now) {\n                    tmp.add(idWord.get(index)); // 转换为对应的word\n                }\n                res.add(tmp);\n            } else { // 该点不为终点 继续搜索\n                for (int i = 0; i < edges[last].size(); i++) {\n                    int to = edges[last].get(i);\n                    // 此处<=目的在于把代价相同的不同路径全部保留下来\n                    if (cost[last] + 1 <= cost[to]) {\n                        cost[to] = cost[last] + 1;\n                        // 把to加入路径中\n                        ArrayList<Integer> tmp = new ArrayList<>(now); tmp.add(to);\n                        q.add(tmp); // 把这个路径加入队列\n                    }\n                }\n            }\n        }\n        return res;\n    }\n\n    // 两个字符串是否可以通过改变一个字母后相等\n    boolean transformCheck(String str1, String str2) {\n        int differences = 0;\n        for (int i = 0; i < str1.length() && differences < 2; i++) {\n            if (str1.charAt(i) != str2.charAt(i)) {\n                ++differences;\n            }\n        }\n        return differences == 1;\n    } \n}\n"}